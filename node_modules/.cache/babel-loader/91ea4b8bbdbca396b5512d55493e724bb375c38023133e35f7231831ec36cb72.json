{"ast":null,"code":"import { useEffect, useMemo, useRef, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { useReadonlyNetworks } from '../providers/network/readonlyNetworks';\nimport { useBlockNumbers, useBlockNumber, useConfig, useResolvedPromise } from '../hooks';\n/**\n * Returns all blockchain logs given a block filter.\n * The hook will cause the component to refresh when a new block is mined and the returned logs change.\n * @see {@link useLogs} for a more easy-to-use version of the query.\n * @param filter an event filter, which blocks to query\n * @param queryParams allows for additional configuration of the query (see {@link QueryParams})\n * @returns an array of [logs](https://docs.ethers.io/v5/api/providers/types/#providers-Log)\n * @public\n */\nexport function useRawLogs(filter, queryParams = {}) {\n  var _a;\n  const {\n    library\n  } = useEthers();\n  const providers = useReadonlyNetworks();\n  const _blockNumber = useBlockNumber();\n  const blockNumbers = useBlockNumbers();\n  const [logs, setLogs] = useState();\n  const [lastContractAddress, setLastContractAddress] = useState();\n  const [lastTopics, setLastTopics] = useState();\n  const [lastChainId, setLastChainId] = useState();\n  const [lastBlockNumber, setLastBlockNumber] = useState();\n  const resolvedFilter = useResolvedPromise(filter);\n  const isLoadingRef = useRef(false);\n  const {\n    chainId,\n    isStatic\n  } = queryParams;\n  const config = useConfig();\n  const refresh = (_a = queryParams === null || queryParams === void 0 ? void 0 : queryParams.refresh) !== null && _a !== void 0 ? _a : config.refresh;\n  const [provider, blockNumber] = useMemo(() => chainId ? [providers[chainId], blockNumbers[chainId]] : [library, _blockNumber], [providers, library, blockNumbers, _blockNumber, chainId]);\n  const deps = [provider];\n  const filterTopicsAsJson = resolvedFilter && JSON.stringify(resolvedFilter.topics);\n  // Push the filter elements to the dependencies. We do this individually b/c hook dependency checks are shallow\n  deps.push(resolvedFilter && resolvedFilter.address);\n  deps.push(filterTopicsAsJson);\n  deps.push(resolvedFilter && resolvedFilter.blockHash);\n  deps.push(resolvedFilter && resolvedFilter.fromBlock);\n  deps.push(resolvedFilter && resolvedFilter.toBlock);\n  // Push the block number if we are not static\n  deps.push(!isStatic && refresh !== 'never' ? blockNumber : 0);\n  useEffect(() => {\n    let active = true; // Flag to indicate if the effect is still in effect\n    async function updateLogs() {\n      if (isLoadingRef.current || !active) {\n        // We are already loading, don't start another request\n        // or the component has been unmounted\n        return;\n      }\n      isLoadingRef.current = true;\n      try {\n        let filterChanged = true;\n        if (chainId === lastChainId && resolvedFilter && lastContractAddress === resolvedFilter.address && lastTopics === filterTopicsAsJson) {\n          // The filter did not change\n          filterChanged = false;\n        } else {\n          // Filter changed. Reset logs\n          setLogs(undefined);\n        }\n        if (!filterChanged) {\n          if (isStatic || refresh === 'never') {\n            // Only update logs if contract address or topics changed\n            return;\n          } else if (typeof refresh === 'number') {\n            // Only update logs if the block number has increased by the refresh interval\n            if (blockNumber && lastBlockNumber && blockNumber - lastBlockNumber < refresh) {\n              return;\n            }\n          }\n        }\n        // Shallow copy the criteria to later store it\n        // This is necessary because the resolved filter can change after the async call, leading to a mismatch and\n        // thus logs being stale\n        const usedContractAddress = !resolvedFilter ? undefined : resolvedFilter.address;\n        const usedTopics = !resolvedFilter ? undefined : JSON.stringify(resolvedFilter.topics);\n        const usedChainId = chainId;\n        const usedBlockNumber = blockNumber;\n        const rawLogs = !resolvedFilter ? undefined : await (provider === null || provider === void 0 ? void 0 : provider.getLogs(resolvedFilter));\n        // Active state could have changed while we were waiting for the logs. Don't update state if it has\n        if (active) {\n          setLogs(rawLogs);\n          setLastContractAddress(usedContractAddress);\n          setLastTopics(usedTopics);\n          setLastChainId(usedChainId);\n          setLastBlockNumber(usedBlockNumber);\n        }\n      } finally {\n        isLoadingRef.current = false;\n      }\n    }\n    void updateLogs();\n    return () => {\n      active = false; // Prevent state updates after the component has unmounted\n    };\n  }, deps);\n  return logs;\n}\n//# sourceMappingURL=useRawLogs.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}