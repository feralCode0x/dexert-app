{"ast":null,"code":"import { utils } from 'ethers';\nimport { defaultMulticall1ErrorMessage } from '../abi/multicall/constants';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function warnOnInvalidCall(call) {\n  if (!call) {\n    return;\n  }\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function validateCall(call) {\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  if (!contract.address || !method) {\n    throw new Error('Missing contract address or method name');\n  }\n  try {\n    contract.interface.encodeFunctionData(method, args);\n    return call;\n  } catch (err) {\n    throw new Error(`Invalid contract call for method=\"${method}\" on contract=\"${contract.address}\": ${err.message}`);\n  }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n * @returns\n * One of these:\n * - a RawCall, if encoding is successful.\n * - Falsy, if there is no call to encode.\n * - an Error, if encoding fails (e.g. because of mismatched arguments).\n */\nexport function encodeCallData(call, chainId, queryParams = {}) {\n  var _a;\n  if (!call) {\n    return undefined;\n  }\n  try {\n    validateCall(call);\n  } catch (e) {\n    return e;\n  }\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  const isStatic = (_a = queryParams.isStatic) !== null && _a !== void 0 ? _a : queryParams.refresh === 'never';\n  const refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined;\n  return {\n    address: contract.address,\n    data: contract.interface.encodeFunctionData(method, args),\n    chainId,\n    isStatic,\n    refreshPerBlocks\n  };\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getUniqueActiveCalls(requests) {\n  const unique = [];\n  const used = {};\n  for (const request of requests) {\n    if (!used[`${request.address.toLowerCase()}${request.data}${request.chainId}`]) {\n      unique.push(request);\n      used[`${request.address.toLowerCase()}${request.data}${request.chainId}`] = true;\n    }\n  }\n  return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getCallsForUpdate(requests, options) {\n  const callsForUpdate = [];\n  for (const request of requests) {\n    if (options) {\n      if (options.chainId && options.chainId !== request.chainId) {\n        continue;\n      }\n      if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n        continue;\n      }\n      const currentBlock = options.blockNumber;\n      if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n        if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n          continue;\n        }\n      }\n    }\n    callsForUpdate.push(request);\n  }\n  return callsForUpdate;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function decodeCallResult(call, result) {\n  var _a;\n  if (!result || !call) {\n    return undefined;\n  }\n  const {\n    value,\n    success\n  } = result;\n  try {\n    if (success) {\n      return {\n        value: call.contract.interface.decodeFunctionResult(call.method, value),\n        error: undefined\n      };\n    } else {\n      const errorMessage = (_a = tryDecodeErrorData(value, call.contract.interface)) !== null && _a !== void 0 ? _a : 'Unknown error';\n      return {\n        value: undefined,\n        error: new Error(errorMessage)\n      };\n    }\n  } catch (error) {\n    return {\n      value: undefined,\n      error: error\n    };\n  }\n}\nfunction tryDecodeErrorData(data, contractInterface) {\n  if (data === '0x') {\n    return 'Call reverted without a cause message';\n  }\n  if (data.startsWith('0x08c379a0')) {\n    // decode Error(string)\n    const reason = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', data)[0];\n    if (reason.startsWith('VM Exception')) {\n      return defaultMulticall1ErrorMessage;\n    }\n    return reason;\n  }\n  if (data.startsWith('0x4e487b71')) {\n    // decode Panic(uint)\n    const code = new utils.Interface(['function Panic(uint)']).decodeFunctionData('Panic', data)[0];\n    return `panic code ${code._hex}`;\n  }\n  try {\n    const errorInfo = contractInterface.parseError(data);\n    return `error ${errorInfo.name}`;\n  } catch (e) {\n    console.error(e);\n  }\n}\n//# sourceMappingURL=calls.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}