{"ast":null,"code":"var _s = $RefreshSig$();\nimport Web3 from \"web3\";\nimport { useEffect, useState } from \"react\";\nimport { useConfig } from \"@usedapp/core\";\nimport { ROUTER_ADDRESS } from \"../config\";\nimport { getFactoryInfo, getRouterInfo } from \"../utils\";\n// eslint-disable-next-line\nimport { ContractFactory, Wallet } from 'ethers';\nimport { Contract, ethers } from 'ethers';\nimport { UniswapV2Pair, UniswapV2Factory } from '../constants';\n/*\nconst packageJson = require('../../package.json');\nconst schema = require('@uniswap/token-lists/src/tokenlist.schema.json');\nconst { getAddress } = require('@ethersproject/address');\nconst buildList = require('../buildList');\nconst Ajv = require('ajv').default;\nconst addFormats = require('ajv-formats').default;\n//const ajv = new Ajv({ allErrors: true, format: 'full' });\nconst ajv = new Ajv();\n  \taddFormats(ajv);\nconst validator = ajv.compile(schema);\nlet defaultTokenList;\nlet before;\n\nconst loadPool = async () => {\n  before(async function () {\n    this.timeout(120000);\n    defaultTokenList = await buildList();\n  });\n  \n  describe('buildList', () => {\n  \n    it('validates', () => {\n      expect(validator(defaultTokenList)).to.equal(true);\n    });\n  \n    it('contains no duplicate addresses', () => {\n      const map = {};\n      for (let token of defaultTokenList.tokens) {\n        const key = `${token.chainId}-${token.address}`;\n        expect(typeof map[key])\n          .to.equal('undefined');\n        map[key] = true;\n      }\n    });\n  \n    it('contains no duplicate symbols', () => {\n      // manual override to approve certain tokens with duplicate symbols\n      const approvedDuplicateSymbols = [\"ust\"];\n  \n      const map = {};\n      for (let token of defaultTokenList.tokens) {\n        let symbol = token.symbol.toLowerCase();\n        if (approvedDuplicateSymbols.includes(symbol)) {\n          continue;\n        } else {\n          const key = `${token.chainId}-${symbol}`;\n          expect(typeof map[key])\n            .to.equal('undefined', `duplicate symbol: ${symbol}`);\n          map[key] = true;\n        }\n      }\n    })\n  \n    it('contains no duplicate names', () => {\n      const map = {};\n      for (let token of defaultTokenList.tokens) {\n        const key = `${token.chainId}-${token.name.toLowerCase()}`;\n        expect(typeof map[key])\n          .to.equal('undefined', `duplicate name: ${token.name}`);\n        map[key] = true;\n      }\n    })\n  \n    it('all addresses are valid and checksummed', () => {\n      for (let token of defaultTokenList.tokens) {\n        expect(getAddress(token.address)).to.eq(token.address);\n      }\n    });\n  \n    it('version matches package.json', () => {\n      expect(packageJson.version).to.match(/^\\d+\\.\\d+\\.\\d+$/);\n      expect(packageJson.version).to.equal(`${defaultTokenList.version.major}.${defaultTokenList.version.minor}.${defaultTokenList.version.patch}`);\n    });\n  });\n}*/\nexport const loadPools = async (providerUrl, deployer, token0, token1) => {\n  const provider = new Web3.providers.HttpProvider(providerUrl);\n  const web3 = new Web3(provider);\n  const routerInfo = await getRouterInfo(ROUTER_ADDRESS, web3);\n  const factoryInfo = await getFactoryInfo(routerInfo.factory, web3);\n  /*const factoryInfo = await getFactoryInfo(routerInfo.uniswapFactory, web3);\n    const uniswapFactory = new ethers.ContractFactory(UniswapV2Factory.abi, UniswapV2Factory.bytecode, deployer)\n  const factoryInfoDeploy = await factoryInfo.deploy(deployer.address)\n  await factoryInfoDeploy.deployed()\n  await factoryInfoDeploy.createPair(token0.address, token1.address)\n  const pairAddress = await factoryInfoDeploy.getPair(token0.address, token1.address)\n  const pairsInfo = new ethers.Contract(pairAddress, JSON.stringify(UniswapV2Pair.abi)).connect(deployer)\n  */\n  return factoryInfo.pairsInfo;\n};\nexport const usePools = () => {\n  _s();\n  const [loading, setLoading] = useState(true);\n  const {\n    readOnlyChainId,\n    readOnlyUrls\n  } = useConfig();\n  const [pools, setPools] = useState({});\n  useEffect(() => {\n    loadPools(readOnlyUrls[readOnlyChainId]).then(pools => {\n      setPools(pools);\n      setLoading(false);\n    });\n  }, [readOnlyUrls, readOnlyChainId]);\n  return [loading, pools];\n};\n_s(usePools, \"Q8ZF1nMAuF3teOlZk4t3eoFD5zw=\", false, function () {\n  return [useConfig];\n});","map":{"version":3,"names":["Web3","useEffect","useState","useConfig","ROUTER_ADDRESS","getFactoryInfo","getRouterInfo","ContractFactory","Wallet","Contract","ethers","UniswapV2Pair","UniswapV2Factory","loadPools","providerUrl","deployer","token0","token1","provider","providers","HttpProvider","web3","routerInfo","factoryInfo","factory","pairsInfo","usePools","_s","loading","setLoading","readOnlyChainId","readOnlyUrls","pools","setPools","then"],"sources":["/home/zetecoder/dexert0/packages/dexert/src/hooks/usePools.js"],"sourcesContent":["import Web3 from \"web3\";\nimport { useEffect, useState } from \"react\";\nimport { useConfig } from \"@usedapp/core\";\nimport { ROUTER_ADDRESS } from \"../config\";\nimport { getFactoryInfo, getRouterInfo } from \"../utils\";\n// eslint-disable-next-line\nimport { ContractFactory, Wallet } from 'ethers'\nimport { Contract, ethers } from 'ethers'\nimport { UniswapV2Pair, UniswapV2Factory } from '../constants'\n/*\nconst packageJson = require('../../package.json');\nconst schema = require('@uniswap/token-lists/src/tokenlist.schema.json');\nconst { getAddress } = require('@ethersproject/address');\nconst buildList = require('../buildList');\nconst Ajv = require('ajv').default;\nconst addFormats = require('ajv-formats').default;\n//const ajv = new Ajv({ allErrors: true, format: 'full' });\nconst ajv = new Ajv();\n  \taddFormats(ajv);\nconst validator = ajv.compile(schema);\nlet defaultTokenList;\nlet before;\n\nconst loadPool = async () => {\n  before(async function () {\n    this.timeout(120000);\n    defaultTokenList = await buildList();\n  });\n  \n  describe('buildList', () => {\n  \n    it('validates', () => {\n      expect(validator(defaultTokenList)).to.equal(true);\n    });\n  \n    it('contains no duplicate addresses', () => {\n      const map = {};\n      for (let token of defaultTokenList.tokens) {\n        const key = `${token.chainId}-${token.address}`;\n        expect(typeof map[key])\n          .to.equal('undefined');\n        map[key] = true;\n      }\n    });\n  \n    it('contains no duplicate symbols', () => {\n      // manual override to approve certain tokens with duplicate symbols\n      const approvedDuplicateSymbols = [\"ust\"];\n  \n      const map = {};\n      for (let token of defaultTokenList.tokens) {\n        let symbol = token.symbol.toLowerCase();\n        if (approvedDuplicateSymbols.includes(symbol)) {\n          continue;\n        } else {\n          const key = `${token.chainId}-${symbol}`;\n          expect(typeof map[key])\n            .to.equal('undefined', `duplicate symbol: ${symbol}`);\n          map[key] = true;\n        }\n      }\n    })\n  \n    it('contains no duplicate names', () => {\n      const map = {};\n      for (let token of defaultTokenList.tokens) {\n        const key = `${token.chainId}-${token.name.toLowerCase()}`;\n        expect(typeof map[key])\n          .to.equal('undefined', `duplicate name: ${token.name}`);\n        map[key] = true;\n      }\n    })\n  \n    it('all addresses are valid and checksummed', () => {\n      for (let token of defaultTokenList.tokens) {\n        expect(getAddress(token.address)).to.eq(token.address);\n      }\n    });\n  \n    it('version matches package.json', () => {\n      expect(packageJson.version).to.match(/^\\d+\\.\\d+\\.\\d+$/);\n      expect(packageJson.version).to.equal(`${defaultTokenList.version.major}.${defaultTokenList.version.minor}.${defaultTokenList.version.patch}`);\n    });\n  });\n}*/\nexport const loadPools = async (providerUrl, deployer: Wallet, token0: Contract, token1: Contract) => {\n\n  const provider = new Web3.providers.HttpProvider(providerUrl);\n  const web3 = new Web3(provider);\n  const routerInfo = await getRouterInfo(ROUTER_ADDRESS, web3);\n  const factoryInfo = await getFactoryInfo(routerInfo.factory, web3);\n  /*const factoryInfo = await getFactoryInfo(routerInfo.uniswapFactory, web3);\n    const uniswapFactory = new ethers.ContractFactory(UniswapV2Factory.abi, UniswapV2Factory.bytecode, deployer)\n  const factoryInfoDeploy = await factoryInfo.deploy(deployer.address)\n  await factoryInfoDeploy.deployed()\n  await factoryInfoDeploy.createPair(token0.address, token1.address)\n  const pairAddress = await factoryInfoDeploy.getPair(token0.address, token1.address)\n  const pairsInfo = new ethers.Contract(pairAddress, JSON.stringify(UniswapV2Pair.abi)).connect(deployer)\n*/\n  return factoryInfo.pairsInfo \n}\n\nexport const usePools = () => {\n  const [loading, setLoading] = useState(true); \n  const { readOnlyChainId, readOnlyUrls } = useConfig();\n  const [pools, setPools] = useState({});\n\n  useEffect(() => {\n    loadPools(readOnlyUrls[readOnlyChainId])\n        .then((pools) => {\n          setPools(pools);\n          setLoading(false);\n        });\n  }, [readOnlyUrls, readOnlyChainId]);\n\n  return [loading, pools];\n}"],"mappings":";AAAA,OAAOA,IAAI,MAAM,MAAM;AACvB,SAASC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAC3C,SAASC,SAAS,QAAQ,eAAe;AACzC,SAASC,cAAc,QAAQ,WAAW;AAC1C,SAASC,cAAc,EAAEC,aAAa,QAAQ,UAAU;AACxD;AACA,SAASC,eAAe,EAAEC,MAAM,QAAQ,QAAQ;AAChD,SAASC,QAAQ,EAAEC,MAAM,QAAQ,QAAQ;AACzC,SAASC,aAAa,EAAEC,gBAAgB,QAAQ,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,SAAS,GAAG,MAAAA,CAAOC,WAAW,EAAEC,QAAgB,EAAEC,MAAgB,EAAEC,MAAgB,KAAK;EAEpG,MAAMC,QAAQ,GAAG,IAAIlB,IAAI,CAACmB,SAAS,CAACC,YAAY,CAACN,WAAW,CAAC;EAC7D,MAAMO,IAAI,GAAG,IAAIrB,IAAI,CAACkB,QAAQ,CAAC;EAC/B,MAAMI,UAAU,GAAG,MAAMhB,aAAa,CAACF,cAAc,EAAEiB,IAAI,CAAC;EAC5D,MAAME,WAAW,GAAG,MAAMlB,cAAc,CAACiB,UAAU,CAACE,OAAO,EAAEH,IAAI,CAAC;EAClE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOE,WAAW,CAACE,SAAS;AAC9B,CAAC;AAED,OAAO,MAAMC,QAAQ,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC5B,MAAM,CAACC,OAAO,EAAEC,UAAU,CAAC,GAAG3B,QAAQ,CAAC,IAAI,CAAC;EAC5C,MAAM;IAAE4B,eAAe;IAAEC;EAAa,CAAC,GAAG5B,SAAS,CAAC,CAAC;EACrD,MAAM,CAAC6B,KAAK,EAAEC,QAAQ,CAAC,GAAG/B,QAAQ,CAAC,CAAC,CAAC,CAAC;EAEtCD,SAAS,CAAC,MAAM;IACdY,SAAS,CAACkB,YAAY,CAACD,eAAe,CAAC,CAAC,CACnCI,IAAI,CAAEF,KAAK,IAAK;MACfC,QAAQ,CAACD,KAAK,CAAC;MACfH,UAAU,CAAC,KAAK,CAAC;IACnB,CAAC,CAAC;EACR,CAAC,EAAE,CAACE,YAAY,EAAED,eAAe,CAAC,CAAC;EAEnC,OAAO,CAACF,OAAO,EAAEI,KAAK,CAAC;AACzB,CAAC;AAAAL,EAAA,CAdYD,QAAQ;EAAA,QAEuBvB,SAAS;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}