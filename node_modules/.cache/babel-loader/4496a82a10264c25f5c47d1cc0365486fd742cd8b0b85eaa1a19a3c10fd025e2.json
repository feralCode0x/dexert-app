{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useMemo, useReducer, useState } from 'react';\nimport { providers } from 'ethers';\nimport { useConfig } from '../../../hooks';\nimport { ReadonlyNetworksContext } from './context';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { networkStatesReducer } from './reducer';\nimport { useWindow } from '../../window';\nimport { isWebSocketProvider } from '../../../helpers';\nconst {\n  Provider,\n  StaticJsonRpcProvider\n} = providers;\nconst getProviderFromConfig = urlOrProviderOrProviderFunction => {\n  if (Provider.isProvider(urlOrProviderOrProviderFunction)) {\n    return urlOrProviderOrProviderFunction;\n  }\n  if (typeof urlOrProviderOrProviderFunction === 'function') {\n    return urlOrProviderOrProviderFunction();\n  }\n  return new StaticJsonRpcProvider(urlOrProviderOrProviderFunction);\n};\nexport const getProvidersFromConfig = readOnlyUrls => fromEntries(Object.entries(readOnlyUrls).map(([chainId, urlOrProviderOrProviderFunction]) => [chainId, getProviderFromConfig(urlOrProviderOrProviderFunction)]));\nexport function ReadonlyNetworksProvider({\n  providerOverrides = {},\n  children\n}) {\n  const {\n    readOnlyUrls = {},\n    pollingInterval,\n    pollingIntervals\n  } = useConfig();\n  const isActive = useWindow();\n  const [providers, setProviders] = useState(() => Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n  const [networkStates, dispatchNetworkState] = useReducer(networkStatesReducer, Object.assign({}, fromEntries(Object.keys(Object.assign(Object.assign({}, readOnlyUrls), providerOverrides)).map(chainId => [chainId, {\n    errors: []\n  }]))));\n  const getPollingInterval = useCallback(chainId => {\n    var _a;\n    return (_a = pollingIntervals === null || pollingIntervals === void 0 ? void 0 : pollingIntervals[chainId]) !== null && _a !== void 0 ? _a : pollingInterval;\n  }, [pollingInterval, pollingIntervals]);\n  useEffect(() => {\n    setProviders(Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n  }, Object.entries(readOnlyUrls).flat());\n  useEffect(() => {\n    for (const [chainId] of Object.entries(readOnlyUrls)) {\n      const provider = providers[chainId];\n      if (provider && !isWebSocketProvider(provider)) {\n        provider.polling = isActive;\n      }\n    }\n  }, [isActive, providers, readOnlyUrls]);\n  useEffect(() => {\n    for (const [chainId, provider] of Object.entries(providers)) {\n      if (!isWebSocketProvider(provider)) {\n        provider.pollingInterval = getPollingInterval(Number(chainId));\n      }\n    }\n  }, [providers, getPollingInterval]);\n  const networks = useMemo(() => ({\n    providers,\n    updateNetworkState: dispatchNetworkState,\n    networkStates\n  }), [providers, dispatchNetworkState, networkStates]);\n  return _jsx(ReadonlyNetworksContext.Provider, Object.assign({\n    value: networks\n  }, {\n    children: children\n  }));\n}\n//# sourceMappingURL=provider.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}