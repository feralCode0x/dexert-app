{"ast":null,"code":"import { decodeUint, wordLength, fail } from '../common';\nexport function decodeTryAggregate(calldata) {\n  // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n  const errorMethodId = '0x08c379a0';\n  if (calldata.startsWith(errorMethodId)) {\n    throw new Error('Multicall2 aggregate: call failed');\n  }\n  calldata = calldata.slice(2); // 'remove 0x prefix'\n  const getNumber = offset => decodeUint(calldata.slice(offset * wordLength, (offset + 1) * wordLength));\n  // The array offset must be 0x20 - nothing is before the array\n  if (getNumber(0) !== 0x20) {\n    fail();\n  }\n  const arraySize = getNumber(1);\n  const calls = [];\n  for (let i = 0; i < arraySize; i++) {\n    // offset of the call number i\n    const callOffset = 2 * getNumber(i + 2) + 2 * wordLength;\n    // position of the call if we split calldata in chunks of 32 bytes\n    const pos = callOffset / wordLength;\n    // returnData is encoded as a flag showing if the call was successful,\n    // data offset, which should be equal to 0x40, data length and the data itself\n    const successEncoded = getNumber(pos);\n    if (successEncoded !== 1 && successEncoded !== 0) {\n      fail();\n    }\n    const success = successEncoded === 1;\n    if (getNumber(pos + 1) !== 0x40) {\n      fail();\n    }\n    const returnDataOffset = (pos + 3) * wordLength;\n    const returnDataLength = getNumber(pos + 2);\n    const returnData = calldata.slice(returnDataOffset, returnDataOffset + 2 * returnDataLength);\n    const call = [success, '0x' + returnData];\n    calls.push(call);\n  }\n  return [calls];\n}\n//# sourceMappingURL=decoder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}