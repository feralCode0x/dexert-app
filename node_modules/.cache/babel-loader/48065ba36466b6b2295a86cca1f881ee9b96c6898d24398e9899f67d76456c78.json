{"ast":null,"code":"import { useMemo } from 'react';\nimport { useRawCalls } from './useRawCalls';\nimport { decodeCallResult, encodeCallData } from '../helpers';\nimport { useChainId } from './useChainId';\nimport { useConfig } from './useConfig';\n/**\n * Makes a call to a specific method of a specific contract and returns the value or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useRawCall} that uses ABI, function name, and arguments instead of raw data.\n * If typechain contract is used in `call` parameter then method name and arguments will be type checked.\n * Result will be typed as well.\n *\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n *\n * @public\n * @param call a single call to a contract, also see {@link Call}\n * @returns The hook returns {@link CallResult} type.\n *\n * @example\n * function useTotalSupply(tokenAddress: string | undefined): BigNumber | undefined {\n *    const { value, error } = useCall(tokenAddress && {\n *      contract: new Contract(tokenAddress, ERC20Interface),\n *      method: 'totalSupply',\n *      args: []\n *    }) ?? {}\n *    if(error) {\n *      console.error(error.message)\n *      return undefined\n *    }\n *    return value?.[0]\n * }\n */\nexport function useCall(call, queryParams = {}) {\n  return useCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific methods of specific contracts and returns values or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useRawCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls, also see {@link Call}.\n * @param queryParams see {@link QueryParams}.\n * @returns a list of results (see {@link CallResult}).\n *\n * @example\n * function useTotalSupplies(tokenAddresses: string[] | undefined): (BigNumber | undefined)[] {\n *   const calls = tokenAddresses?.map(address => ({\n *     contract: new Contract(address, ERC20Interface),\n *     method: 'totalSupply',\n *     args: []\n *   })) ?? []\n *   const results = useCalls(calls) ?? []\n *   results.forEach((result, idx) => {\n *     if(result && result.error) {\n *       console.error(`Error encountered calling 'totalSupply' on ${calls[idx]?.contract.address}: ${result.error.message}`)\n *     }\n *   })\n *   return results.map(result => result?.value?.[0])\n * }\n */\nexport function useCalls(calls, queryParams = {}) {\n  const chainId = useChainId({\n    queryParams\n  });\n  const {\n    refresh\n  } = useConfig();\n  const potentialRawCalls = useMemo(() => calls.map(call => {\n    var _a;\n    return chainId !== undefined ? encodeCallData(call, chainId, Object.assign(Object.assign({}, queryParams), {\n      refresh: (_a = queryParams.refresh) !== null && _a !== void 0 ? _a : refresh\n    })) : undefined;\n  }), [JSON.stringify(calls.map(call => call && {\n    address: call.contract.address.toLowerCase(),\n    method: call.method,\n    args: call.args\n  })), chainId]);\n  const rawCalls = useMemo(() => potentialRawCalls.map(potentialCall => potentialCall instanceof Error ? undefined : potentialCall), [potentialRawCalls]);\n  const results = useRawCalls(rawCalls);\n  return useMemo(() => results.map((result, idx) => {\n    if (potentialRawCalls[idx] instanceof Error) {\n      return {\n        value: undefined,\n        error: potentialRawCalls[idx]\n      };\n    }\n    return decodeCallResult(calls[idx], result);\n  }), [results]);\n}\n//# sourceMappingURL=useCall.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}