{"ast":null,"code":"export class Event {\n  constructor() {\n    this._listeners = new Set();\n    this._effects = new Set();\n  }\n  emit(data) {\n    for (const listener of Array.from(this._listeners)) {\n      void this._trigger(listener, data);\n    }\n  }\n  on(callback) {\n    this._listeners.add(callback);\n    if (this.listenerCount() === 1) {\n      this._runEffects();\n    }\n    return () => this.off(callback);\n  }\n  off(callback) {\n    this._listeners.delete(callback);\n    if (this.listenerCount() === 0) {\n      this._cleanupEffects();\n    }\n  }\n  listenerCount() {\n    return this._listeners.size;\n  }\n  addEffect(effect) {\n    const handle = {\n      effect,\n      cleanup: undefined\n    };\n    if (this.listenerCount() > 0) {\n      const cleanup = handle.effect();\n      if (typeof cleanup === 'function') {\n        handle.cleanup = cleanup;\n      }\n    }\n    this._effects.add(handle);\n    return () => {\n      var _a;\n      // eslint-disable-next-line no-unused-expressions\n      (_a = handle.cleanup) === null || _a === void 0 ? void 0 : _a.call(handle);\n      this._effects.delete(handle);\n    };\n  }\n  async _trigger(listener, data) {\n    try {\n      await waitImmediate(); // Acts like setImmediate but preserves the stack-trace.\n      listener(data);\n    } catch (error) {\n      // Stop error propagation.\n      throwUnhandledRejection(error);\n    }\n  }\n  _runEffects() {\n    for (const handle of Array.from(this._effects)) {\n      const cleanup = handle.effect();\n      if (typeof cleanup === 'function') {\n        handle.cleanup = cleanup;\n      }\n    }\n  }\n  _cleanupEffects() {\n    var _a;\n    for (const handle of Array.from(this._effects)) {\n      // eslint-disable-next-line no-unused-expressions\n      (_a = handle.cleanup) === null || _a === void 0 ? void 0 : _a.call(handle);\n      handle.cleanup = undefined;\n    }\n  }\n}\nfunction throwUnhandledRejection(error) {\n  setTimeout(() => {\n    throw error;\n  });\n}\n/**\n * Like setImmediate but for async/await API. Useful for preserving stack-traces.\n */\nconst waitImmediate = () => new Promise(resolve => setTimeout(resolve));\n//# sourceMappingURL=event.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}