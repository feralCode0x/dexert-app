{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { providers } from 'ethers';\nimport { getAddress } from 'ethers/lib/utils';\nimport { createContext, useCallback, useContext, useEffect, useState } from 'react';\nimport { useConfig, useLocalStorage, useReadonlyNetwork } from '../../../hooks';\nimport { useReadonlyNetworkStates } from '../readonlyNetworks/context';\nimport { ConnectorController } from './connectorController';\nimport { InjectedConnector } from './implementations';\nconst Provider = providers.Provider;\nconst getAccount = connector => {\n  if (connector === null || connector === void 0 ? void 0 : connector.accounts[0]) {\n    return getAddress(connector.accounts[0]);\n  }\n  return undefined;\n};\nexport const ConnectorContext = createContext({\n  connector: undefined,\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  activate: async () => {},\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  deactivate: () => {},\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  activateBrowserWallet: () => {},\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  reportError: () => {},\n  isLoading: true,\n  setError: () => {\n    throw new Error('Function not implemented.');\n  },\n  active: false,\n  switchNetwork: () => {\n    throw new Error('Function not implemented.');\n  }\n});\nexport function ConnectorContextProvider({\n  children\n}) {\n  var _a;\n  const [controller, setController] = useState();\n  const [isLoading, setLoading] = useState(true);\n  const config = useConfig();\n  const {\n    connectors,\n    autoConnect\n  } = config;\n  const [autoConnectTag, setAutoConnectTag] = useLocalStorage('usedapp:autoConnectTag');\n  const activate = useCallback(async (providerOrConnector, {\n    silently,\n    onSuccess\n  } = {\n    silently: false\n  }) => {\n    let controller;\n    if ('activate' in providerOrConnector) {\n      controller = new ConnectorController(providerOrConnector, config);\n    } else {\n      const wrappedProvider = Provider.isProvider(providerOrConnector) ? providerOrConnector : new providers.Web3Provider(providerOrConnector);\n      controller = new ConnectorController(new InjectedConnector(wrappedProvider), config);\n    }\n    setLoading(true);\n    setController(controller);\n    try {\n      if (silently) {\n        await controller.activate(connector => connector.connectEagerly());\n      } else {\n        await controller.activate();\n      }\n      setLoading(false);\n      onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess();\n    } catch (error) {\n      controller.reportError(error);\n    } finally {\n      setLoading(false);\n    }\n  }, [setController, setLoading]);\n  const activateBrowserWallet = useCallback(async options => {\n    // done for backward compatibility.\n    // If the options object looks like an event object or is undefined,\n    // it's not a valid option and will be ignored\n    if (!options || typeof options.preventDefault === 'function') {\n      options = {\n        type: 'metamask'\n      };\n    }\n    const {\n      type\n    } = options;\n    if (!connectors[type]) {\n      throw new Error(`Connector ${type} is not configured`);\n    }\n    await activate(connectors[type], {\n      onSuccess: () => {\n        setAutoConnectTag(type);\n      }\n    });\n  }, [activate, setAutoConnectTag, connectors]);\n  const deactivate = useCallback(async () => {\n    setAutoConnectTag(undefined);\n    setLoading(true);\n    setController(undefined);\n    await (controller === null || controller === void 0 ? void 0 : controller.deactivate());\n    setLoading(false);\n  }, [controller]);\n  const reportError = useCallback(err => {\n    controller === null || controller === void 0 ? void 0 : controller.reportError(err);\n  }, [controller]);\n  const switchNetwork = useCallback(async chainId => {\n    await (controller === null || controller === void 0 ? void 0 : controller.switchNetwork(chainId));\n  }, [controller]);\n  const setErrorDeprecated = useCallback(() => {\n    throw new Error('setError is deprecated');\n  }, []);\n  const ethersActivate = useCallback(async providerOrConnector => {\n    if ('getProvider' in providerOrConnector) {\n      console.warn('Using web3-react connectors is deprecated and may lead to unexpected behavior.');\n      await providerOrConnector.activate();\n      return activate(await providerOrConnector.getProvider());\n    }\n    return activate(providerOrConnector);\n  }, []);\n  useEffect(() => {\n    if (autoConnect && autoConnectTag && connectors[autoConnectTag]) {\n      void activate(connectors[autoConnectTag], {\n        silently: true\n      });\n    } else {\n      setLoading(false);\n    }\n  }, []);\n  useEffect(() => {\n    controller === null || controller === void 0 ? void 0 : controller.updateConfig(config);\n  }, [controller, config]);\n  const readonlyNetwork = useReadonlyNetwork();\n  const [errors, setErrors] = useState((_a = controller === null || controller === void 0 ? void 0 : controller.errors) !== null && _a !== void 0 ? _a : []);\n  const [account, setAccount] = useState(getAccount(controller));\n  const [provider, setProvider] = useState(controller === null || controller === void 0 ? void 0 : controller.getProvider());\n  const [chainId, setChainId] = useState(controller === null || controller === void 0 ? void 0 : controller.chainId);\n  useEffect(() => {\n    if (!(controller === null || controller === void 0 ? void 0 : controller.getProvider())) {\n      setAccount(undefined);\n      setProvider(readonlyNetwork === null || readonlyNetwork === void 0 ? void 0 : readonlyNetwork.provider);\n      setChainId(readonlyNetwork === null || readonlyNetwork === void 0 ? void 0 : readonlyNetwork.chainId);\n      setErrors([]);\n    } else {\n      setChainId(controller.chainId);\n      setErrors(controller.errors);\n      setProvider(controller.getProvider());\n      setAccount(getAccount(controller));\n    }\n    return controller === null || controller === void 0 ? void 0 : controller.updated.on(({\n      chainId,\n      errors,\n      accounts\n    }) => {\n      if (chainId) {\n        setChainId(chainId);\n        setProvider(controller.getProvider());\n        if (accounts[0]) {\n          setAccount(getAddress(accounts[0]));\n        } else {\n          setAccount(undefined);\n        }\n      }\n      setErrors([...errors]);\n    });\n  }, [controller, controller === null || controller === void 0 ? void 0 : controller.getProvider(), readonlyNetwork]);\n  const {\n    networks,\n    readOnlyUrls\n  } = useConfig();\n  const [error, setError] = useState(undefined);\n  const networkStates = useReadonlyNetworkStates();\n  const configuredChainIds = Object.keys(readOnlyUrls || {}).map(chainId => parseInt(chainId, 10));\n  const supportedChainIds = networks === null || networks === void 0 ? void 0 : networks.map(network => network.chainId);\n  useEffect(() => {\n    const isNotConfiguredChainId = chainId && configuredChainIds && configuredChainIds.indexOf(chainId) < 0;\n    const isUnsupportedChainId = chainId && supportedChainIds && supportedChainIds.indexOf(chainId) < 0;\n    if (isUnsupportedChainId || isNotConfiguredChainId) {\n      const chainIdError = new Error(`${isUnsupportedChainId ? 'Unsupported' : 'Not configured'} chain id: ${chainId}.`);\n      chainIdError.name = 'ChainIdError';\n      setError(chainIdError);\n      return;\n    }\n    for (const networkState of Object.values(networkStates)) {\n      if (networkState.errors.length > 0) {\n        setError(networkState.errors[networkState.errors.length - 1]);\n        return;\n      }\n    }\n    setError(errors === null || errors === void 0 ? void 0 : errors[errors.length - 1]);\n  }, [chainId, errors, networkStates]);\n  return _jsx(ConnectorContext.Provider, Object.assign({\n    value: {\n      connector: controller,\n      deactivate,\n      reportError,\n      activate: ethersActivate,\n      activateBrowserWallet,\n      isLoading,\n      account,\n      library: provider,\n      chainId: (error === null || error === void 0 ? void 0 : error.name) === 'ChainIdError' ? undefined : provider !== undefined ? chainId : readonlyNetwork === null || readonlyNetwork === void 0 ? void 0 : readonlyNetwork.chainId,\n      error,\n      active: !!provider,\n      switchNetwork,\n      setError: setErrorDeprecated\n    }\n  }, {\n    children: children\n  }));\n}\nexport const useConnector = () => useContext(ConnectorContext);\n//# sourceMappingURL=context.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}