{"ast":null,"code":"import { useCallback, useState } from 'react';\nimport { useNotificationsContext, useTransactionsContext } from '../providers';\nimport { BigNumber, errors } from 'ethers';\nimport { buildSafeTransaction, getLatestNonce } from '../helpers/gnosisSafeUtils';\nimport { useEthers } from './useEthers';\nimport { waitForSafeTransaction } from '../helpers/gnosisSafeUtils';\nimport { useGnosisSafeContract } from './useGnosisSafeContract';\n/**\n * @internal\n */\nexport async function estimateTransactionGasLimit(transactionRequest, signer, gasLimitBufferPercentage) {\n  if (!signer || !transactionRequest) {\n    return undefined;\n  }\n  try {\n    const estimatedGas = transactionRequest.gasLimit ? BigNumber.from(transactionRequest.gasLimit) : await signer.estimateGas(transactionRequest);\n    return estimatedGas === null || estimatedGas === void 0 ? void 0 : estimatedGas.mul(gasLimitBufferPercentage + 100).div(100);\n  } catch (err) {\n    console.error(err);\n    return undefined;\n  }\n}\n/**\n * @internal\n */\nexport async function estimateContractFunctionGasLimit(contractWithSigner, functionName, args, gasLimitBufferPercentage) {\n  try {\n    const estimatedGas = await contractWithSigner.estimateGas[functionName](...args);\n    const gasLimit = estimatedGas === null || estimatedGas === void 0 ? void 0 : estimatedGas.mul(gasLimitBufferPercentage + 100).div(100);\n    return gasLimit;\n  } catch (err) {\n    console.error(err);\n    return undefined;\n  }\n}\n/**\n * @internal\n */\nasync function isNonContractWallet(library, address) {\n  if (!library || !address) {\n    return true;\n  }\n  const code = await library.getCode(address);\n  return code === '0x';\n}\nconst isDroppedAndReplaced = e => (e === null || e === void 0 ? void 0 : e.code) === errors.TRANSACTION_REPLACED && (e === null || e === void 0 ? void 0 : e.replacement) && ((e === null || e === void 0 ? void 0 : e.reason) === 'repriced' || (e === null || e === void 0 ? void 0 : e.cancelled) === false);\nexport function usePromiseTransaction(chainId, options) {\n  const [state, setState] = useState({\n    status: 'None',\n    transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n  });\n  const {\n    addTransaction,\n    updateTransaction\n  } = useTransactionsContext();\n  const {\n    addNotification\n  } = useNotificationsContext();\n  const {\n    library,\n    account\n  } = useEthers();\n  const gnosisSafe = useGnosisSafeContract(account, library);\n  const resetState = useCallback(() => {\n    setState(({\n      transactionName\n    }) => ({\n      status: 'None',\n      transactionName\n    }));\n  }, [setState]);\n  const promiseTransaction = useCallback(async (transactionPromise, {\n    safeTransaction\n  } = {}, transactionRequest) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;\n    const handleNonContractWallet = async transaction => {\n      if (!chainId) return;\n      setState(({\n        transactionName\n      }) => ({\n        transactionName,\n        transaction,\n        status: 'Mining'\n      }));\n      addTransaction({\n        transaction: Object.assign(Object.assign({}, transaction), {\n          chainId\n        }),\n        submittedAt: Date.now(),\n        transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n      });\n      const receipt = await transaction.wait();\n      updateTransaction({\n        transaction: Object.assign(Object.assign({}, transaction), {\n          chainId: chainId\n        }),\n        receipt,\n        transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n      });\n      setState({\n        receipt,\n        transaction,\n        status: 'Success',\n        chainId,\n        transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n      });\n      return {\n        transaction,\n        receipt\n      };\n    };\n    const handleContractWallet = async (transactionPromise, {\n      safeTransaction\n    } = {}) => {\n      var _a;\n      if (!chainId || !library || !account) return;\n      setState({\n        status: 'CollectingSignaturePool',\n        chainId,\n        transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n      });\n      const gnosisSafeContract = gnosisSafe.get();\n      if (!gnosisSafeContract) {\n        throw new Error(\"Couldn't create Gnosis Safe contract instance\");\n      }\n      const latestNonce = await getLatestNonce(chainId, account);\n      const safeTx = buildSafeTransaction({\n        to: (_a = safeTransaction === null || safeTransaction === void 0 ? void 0 : safeTransaction.to) !== null && _a !== void 0 ? _a : '',\n        value: safeTransaction === null || safeTransaction === void 0 ? void 0 : safeTransaction.value,\n        data: safeTransaction === null || safeTransaction === void 0 ? void 0 : safeTransaction.data,\n        safeTxGas: safeTransaction === null || safeTransaction === void 0 ? void 0 : safeTransaction.safeTxGas,\n        nonce: latestNonce ? latestNonce + 1 : await gnosisSafeContract.nonce()\n      });\n      const {\n        transaction,\n        receipt,\n        rejected\n      } = await waitForSafeTransaction(transactionPromise, gnosisSafeContract, chainId, safeTx);\n      if (rejected) {\n        const errorMessage = 'On-chain rejection created';\n        addTransaction({\n          transaction: Object.assign(Object.assign({}, transaction), {\n            chainId: chainId\n          }),\n          receipt,\n          submittedAt: Date.now(),\n          transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n        });\n        setState({\n          status: 'Fail',\n          transaction,\n          receipt,\n          errorMessage,\n          chainId,\n          transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n        });\n      } else {\n        addTransaction({\n          transaction: Object.assign(Object.assign({}, transaction), {\n            chainId: chainId\n          }),\n          receipt,\n          submittedAt: Date.now(),\n          transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n        });\n        setState({\n          receipt,\n          transaction,\n          status: 'Success',\n          chainId,\n          transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n        });\n      }\n      return {\n        transaction,\n        receipt\n      };\n    };\n    if (!chainId) return;\n    let transaction = undefined;\n    try {\n      setState({\n        status: 'PendingSignature',\n        chainId,\n        transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n      });\n      if (options === null || options === void 0 ? void 0 : options.enablePendingSignatureNotification) {\n        addNotification({\n          notification: {\n            type: 'transactionPendingSignature',\n            submittedAt: Date.now(),\n            transactionName: options === null || options === void 0 ? void 0 : options.transactionName,\n            transactionRequest\n          },\n          chainId: chainId\n        });\n      }\n      const isContractWallet = !(await isNonContractWallet(library, account));\n      if (isContractWallet) {\n        const result = await handleContractWallet(transactionPromise, {\n          safeTransaction\n        });\n        transaction = result === null || result === void 0 ? void 0 : result.transaction;\n        return result === null || result === void 0 ? void 0 : result.receipt;\n      } else {\n        transaction = await transactionPromise;\n        const result = await handleNonContractWallet(transaction);\n        transaction = result === null || result === void 0 ? void 0 : result.transaction;\n        return result === null || result === void 0 ? void 0 : result.receipt;\n      }\n    } catch (e) {\n      const parsedErrorCode = parseInt((_g = (_e = (_c = (_b = (_a = e.error) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.code) !== null && _c !== void 0 ? _c : (_d = e.error) === null || _d === void 0 ? void 0 : _d.code) !== null && _e !== void 0 ? _e : (_f = e.data) === null || _f === void 0 ? void 0 : _f.code) !== null && _g !== void 0 ? _g : e.code);\n      const errorCode = isNaN(parsedErrorCode) ? undefined : parsedErrorCode;\n      const errorHash = (_l = (_k = (_j = (_h = e === null || e === void 0 ? void 0 : e.error) === null || _h === void 0 ? void 0 : _h.data) === null || _j === void 0 ? void 0 : _j.originalError) === null || _k === void 0 ? void 0 : _k.data) !== null && _l !== void 0 ? _l : (_m = e === null || e === void 0 ? void 0 : e.error) === null || _m === void 0 ? void 0 : _m.data;\n      const errorMessage = (_v = (_t = (_s = (_q = (_p = (_o = e.error) === null || _o === void 0 ? void 0 : _o.data) === null || _p === void 0 ? void 0 : _p.message) !== null && _q !== void 0 ? _q : (_r = e.error) === null || _r === void 0 ? void 0 : _r.message) !== null && _s !== void 0 ? _s : e.reason) !== null && _t !== void 0 ? _t : (_u = e.data) === null || _u === void 0 ? void 0 : _u.message) !== null && _v !== void 0 ? _v : e.message;\n      if (transaction) {\n        const droppedAndReplaced = isDroppedAndReplaced(e);\n        if (droppedAndReplaced) {\n          const status = e.receipt.status === 0 ? 'Fail' : 'Success';\n          const type = status === 'Fail' ? 'transactionFailed' : 'transactionSucceed';\n          addNotification({\n            notification: {\n              type,\n              submittedAt: Date.now(),\n              transaction: e.replacement,\n              receipt: e.receipt,\n              transactionName: (_w = e.replacement) === null || _w === void 0 ? void 0 : _w.transactionName,\n              originalTransaction: transaction\n            },\n            chainId\n          });\n          setState(prevState => {\n            var _a;\n            return Object.assign(Object.assign({}, prevState), {\n              status,\n              transaction: e.replacement,\n              originalTransaction: transaction,\n              receipt: e.receipt,\n              transactionName: (_a = e.replacement) === null || _a === void 0 ? void 0 : _a.transactionName,\n              errorMessage,\n              errorCode,\n              errorHash,\n              chainId\n            });\n          });\n        } else {\n          setState({\n            status: 'Fail',\n            transaction,\n            receipt: e.receipt,\n            errorMessage,\n            errorCode,\n            errorHash,\n            chainId,\n            transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n          });\n        }\n      } else {\n        setState({\n          status: 'Exception',\n          errorMessage,\n          errorCode,\n          errorHash,\n          chainId,\n          transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n        });\n      }\n      return undefined;\n    }\n  }, [chainId, addNotification, options === null || options === void 0 ? void 0 : options.transactionName, library, account]);\n  return {\n    promiseTransaction,\n    state,\n    resetState\n  };\n}\n//# sourceMappingURL=usePromiseTransaction.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}