{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useReducer } from 'react';\nimport { useDebouncePair, useBlockNumbers } from '../../../hooks';\nimport { MultiChainStatesContext } from './context';\nimport { useConfig } from '../../..';\nimport { useConnector, useReadonlyNetworks } from '../../network';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { performMulticall } from '../common/performMulticall';\nimport { callsReducer, chainStateReducer, multicall1Factory, multicall2Factory } from '../common';\nimport { getCallsForUpdate, getUniqueActiveCalls } from '../../../helpers';\nimport { useDevtoolsReporting } from '../common/useDevtoolsReporting';\nimport { useChainId } from '../../../hooks/useChainId';\nimport { useWindow } from '../../window/context';\nimport { useUpdateNetworksState } from '../../network/readonlyNetworks/context';\nfunction composeChainState(networks, state, multicallAddresses) {\n  return fromEntries(Object.keys(networks).map(chainId => [Number(chainId), {\n    value: state[Number(chainId)],\n    multicallAddress: multicallAddresses[Number(chainId)]\n  }]));\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stripCall = _a => {\n  var {\n      isStatic,\n      lastUpdatedBlockNumber\n    } = _a,\n    strippedCall = __rest(_a, [\"isStatic\", \"lastUpdatedBlockNumber\"]);\n  return strippedCall;\n};\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function MultiChainStateProvider({\n  children,\n  multicallAddresses\n}) {\n  const {\n    multicallVersion,\n    fastMulticallEncoding\n  } = useConfig();\n  const networks = useReadonlyNetworks();\n  const blockNumbers = useBlockNumbers();\n  const dispatchNetworksState = useUpdateNetworksState();\n  const isActive = useWindow();\n  const [calls, dispatchCalls] = useReducer(callsReducer, []);\n  const [state, dispatchState] = useReducer(chainStateReducer, {});\n  const {\n    reportError\n  } = useConnector();\n  const multicall = (multicallVersion === 1 ? multicall1Factory : multicall2Factory)(fastMulticallEncoding !== null && fastMulticallEncoding !== void 0 ? fastMulticallEncoding : false);\n  const [debouncedCalls, debouncedNetworks] = useDebouncePair(calls, networks, 50);\n  const uniqueCalls = useMemo(() => getUniqueActiveCalls(debouncedCalls), [debouncedCalls]);\n  // used for deep equality in hook dependencies\n  const uniqueCallsJSON = JSON.stringify(debouncedCalls.map(stripCall));\n  const chainId = useChainId();\n  useDevtoolsReporting(uniqueCallsJSON, uniqueCalls, chainId !== undefined ? blockNumbers[chainId] : undefined, multicallAddresses);\n  function multicallForChain(chainId, provider) {\n    if (!isActive) {\n      return;\n    }\n    const blockNumber = blockNumbers[chainId];\n    const multicallAddress = multicallAddresses[chainId];\n    if (!provider || !blockNumber) {\n      return;\n    }\n    if (debouncedNetworks !== networks) {\n      // Wait for debounce to catch up.\n      return;\n    }\n    const updatedCalls = getCallsForUpdate(debouncedCalls, {\n      chainId,\n      blockNumber\n    });\n    const callsOnThisChain = getUniqueActiveCalls(updatedCalls);\n    if (callsOnThisChain.length > 0 && !multicallAddress) {\n      reportError(new Error(`Missing multicall address for chain id ${chainId}`));\n      return;\n    }\n    performMulticall(provider, multicall, multicallAddress, blockNumber, callsOnThisChain, dispatchState, chainId, error => {\n      dispatchNetworksState({\n        type: 'ADD_ERROR',\n        chainId,\n        error\n      });\n    });\n    dispatchCalls({\n      type: 'UPDATE_CALLS',\n      calls,\n      updatedCalls,\n      blockNumber,\n      chainId\n    });\n  }\n  useEffect(() => {\n    var _a, _b;\n    for (const [_chainId, provider] of Object.entries(networks)) {\n      const chainId = Number(_chainId);\n      // chainId is in provider is not the same as the chainId in the state wait for chainId to catch up\n      if (chainId === ((_a = provider.network) === null || _a === void 0 ? void 0 : _a.chainId) || chainId === ((_b = provider._network) === null || _b === void 0 ? void 0 : _b.chainId)) {\n        multicallForChain(chainId, provider);\n      }\n    }\n  }, [networks, multicallAddresses, uniqueCallsJSON, blockNumbers]);\n  const chains = useMemo(() => composeChainState(networks, state, multicallAddresses), [state, multicallAddresses, networks]);\n  const provided = {\n    chains,\n    dispatchCalls\n  };\n  return _jsx(MultiChainStatesContext.Provider, {\n    value: provided,\n    children: children\n  });\n}\n//# sourceMappingURL=provider.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}