{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useReducer } from 'react';\nimport { useEthers, useLocalStorage, useConfig } from '../../hooks';\nimport { useIsMounted } from '../../hooks/useIsMounted';\nimport { useNotificationsContext } from '../notifications/context';\nimport { TransactionsContext } from './context';\nimport { DEFAULT_STORED_TRANSACTIONS } from './model';\nimport { transactionReducer } from './reducer';\nexport function TransactionProvider({\n  children\n}) {\n  const {\n    chainId,\n    library\n  } = useEthers();\n  const {\n    localStorage\n  } = useConfig();\n  const [storage, setStorage] = useLocalStorage(localStorage.transactionPath);\n  const [transactions, dispatch] = useReducer(transactionReducer, storage !== null && storage !== void 0 ? storage : DEFAULT_STORED_TRANSACTIONS);\n  const {\n    addNotification\n  } = useNotificationsContext();\n  const isMounted = useIsMounted();\n  useEffect(() => {\n    setStorage(transactions);\n  }, [transactions]);\n  const addTransaction = useCallback(payload => {\n    if (!isMounted()) {\n      return;\n    }\n    dispatch({\n      type: 'ADD_TRANSACTION',\n      payload\n    });\n    if (payload.receipt) {\n      const type = payload.receipt.status === 0 ? 'transactionFailed' : 'transactionSucceed';\n      addNotification({\n        notification: {\n          type,\n          submittedAt: Date.now(),\n          transaction: payload.transaction,\n          receipt: payload.receipt,\n          transactionName: payload.transactionName\n        },\n        chainId: payload.transaction.chainId\n      });\n      return;\n    }\n    addNotification({\n      notification: {\n        type: 'transactionStarted',\n        transaction: payload.transaction,\n        submittedAt: payload.submittedAt,\n        transactionName: payload.transactionName\n      },\n      chainId: payload.transaction.chainId\n    });\n  }, [dispatch]);\n  const updateTransaction = useCallback(payload => {\n    if (!isMounted()) {\n      return;\n    }\n    dispatch({\n      type: 'UPDATE_TRANSACTION',\n      payload\n    });\n    const type = payload.receipt.status === 0 ? 'transactionFailed' : 'transactionSucceed';\n    addNotification({\n      notification: {\n        type,\n        submittedAt: Date.now(),\n        transaction: payload.transaction,\n        receipt: payload.receipt,\n        transactionName: payload.transactionName\n      },\n      chainId: payload.transaction.chainId\n    });\n  }, [dispatch]);\n  useEffect(() => {\n    const updateTransactions = async () => {\n      var _a;\n      if (!chainId || !library) return;\n      const blockNumber = await library.getBlockNumber();\n      const checkTransaction = async tx => {\n        if (tx.receipt || !shouldCheck(blockNumber, tx)) {\n          return tx;\n        }\n        try {\n          const receipt = await library.getTransactionReceipt(tx.transaction.hash);\n          if (receipt) {\n            const type = receipt.status === 0 ? 'transactionFailed' : 'transactionSucceed';\n            addNotification({\n              notification: {\n                type,\n                submittedAt: Date.now(),\n                transaction: tx.transaction,\n                receipt,\n                transactionName: tx.transactionName\n              },\n              chainId\n            });\n            return Object.assign(Object.assign({}, tx), {\n              receipt\n            });\n          } else {\n            return Object.assign(Object.assign({}, tx), {\n              lastCheckedBlockNumber: blockNumber\n            });\n          }\n        } catch (error) {\n          console.error(`failed to check transaction hash: ${tx.transaction.hash}`, error);\n        }\n        return tx;\n      };\n      const chainTransactions = (_a = transactions[chainId]) !== null && _a !== void 0 ? _a : [];\n      const newTransactions = [];\n      for (const tx of chainTransactions) {\n        const newTransaction = await checkTransaction(tx);\n        newTransactions.push(newTransaction);\n      }\n      if (isMounted()) {\n        dispatch({\n          type: 'UPDATE_TRANSACTIONS',\n          chainId,\n          transactions: newTransactions\n        });\n      }\n    };\n    void updateTransactions();\n  }, [chainId, library]);\n  return _jsx(TransactionsContext.Provider, {\n    value: {\n      transactions,\n      addTransaction,\n      updateTransaction\n    },\n    children: children\n  });\n}\nfunction shouldCheck(blockNumber, tx) {\n  if (tx.receipt) {\n    return false;\n  }\n  if (!tx.lastCheckedBlockNumber) {\n    return true;\n  }\n  const blocksSinceCheck = blockNumber - tx.lastCheckedBlockNumber;\n  if (blocksSinceCheck < 1) {\n    return false;\n  }\n  const minutesPending = (Date.now() - tx.submittedAt) / 1000 / 60;\n  if (minutesPending > 60) {\n    // every 10 blocks if pending for longer than an hour\n    return blocksSinceCheck > 9;\n  }\n  if (minutesPending > 5) {\n    // every 3 blocks if pending more than 5 minutes\n    return blocksSinceCheck > 2;\n  }\n  // otherwise every block\n  return true;\n}\n//# sourceMappingURL=provider.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}